<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Phonetic Tree & Spiral Visualizer</title>
  <style>
    body {
      margin: 0;
      font-family: sans-serif;
      background: #1a1a2e;
      color: #fff;
    }
    #controls {
      padding: 1em;
      background: #16213e;
      display: flex;
      justify-content: center;
      align-items: center;
      gap: 1em;
    }
    #controls input {
      font-size: 1em;
      padding: 0.5em;
      border-radius: 6px;
      border: none;
    }
    #visualizationSelect {
      appearance: none;
      background-color: #e94560;
      color: white;
      border: none;
      padding: 0.5em 1em;
      font-size: 1em;
      border-radius: 6px;
      cursor: pointer;
    }
    #tree, #spiral, #ripple, #fractal, #constellation, #waveform {
      width: 100%;
      height: 600px;
    }
    .node circle {
      fill: #e94560;
    }
    .node text {
      fill: white;
      font-size: 12px;
    }
    .link {
      fill: none;
      stroke: #fff;
      stroke-opacity: 0.5;
    }
    #typewriterContainer {
      text-align: center;
      padding: 1em;
      background: #16213e;
      margin-bottom: 1em;
      position: relative;
    }
    
    #typewriterText {
      font-family: monospace;
      font-size: 1.5em;
      color: #e94560;
      margin: 0;
      min-height: 1.5em;
      border-right: 0.15em solid #e94560;
      white-space: nowrap;
      overflow: hidden;
      letter-spacing: 0.1em;
      text-overflow: ellipsis;
      transition: font-size 0.3s ease;
    }
    
    /* Visualization container for zoom/pan */
    .visualization-container {
      position: relative;
      overflow: hidden;
      width: 100%;
      height: 600px;
    }
    
    
    /* Add cursor styles to indicate interactive elements */
    #tree, #spiral, #ripple, #fractal, #constellation, #waveform {
      cursor: grab;
    }
    
    #tree:active, #spiral:active, #ripple:active, #fractal:active, #constellation:active, #waveform:active {
      cursor: grabbing;
    }
  </style>
</head>
<body>
<div id="controls">
  <input id="wordInput" type="text" placeholder="Enter a word" />
  <select id="visualizationSelect">
    <option value="" disabled selected hidden>üîç Select Visualization</option>
    <option value="tree">Recursive Tree</option>
    <option value="spiral">Spiral Path</option>
    <option value="ripple1">Radial Expansion</option>
    <option value="ripple2">Concentric Waves</option>
    <option value="ripple3">Animated Pulse</option>
    <option value="fractal">Fractal Garden</option>
    <option value="constellation">Constellation</option>
    <option value="waveform">Waveform</option>
  </select>
</div>
<div id="typewriterContainer">
  <h2 id="typewriterText"></h2>
</div>

<div class="visualization-container" id="treeContainer">
  <svg id="tree"></svg>
</div>

<div class="visualization-container" id="spiralContainer">
  <canvas id="spiral"></canvas>
</div>

<div class="visualization-container" id="rippleContainer">
  <canvas id="ripple"></canvas>
</div>

<div class="visualization-container" id="fractalContainer">
  <canvas id="fractal"></canvas>
</div>

<div class="visualization-container" id="constellationContainer">
  <canvas id="constellation"></canvas>
</div>

<div class="visualization-container" id="waveformContainer">
  <canvas id="waveform"></canvas>
</div>
<script src="https://d3js.org/d3.v7.min.js"></script>
<script>
const phoneticMap = {
  a: "ay", b: "bee", c: "see", d: "dee", e: "ee", f: "ef",
  g: "jee", h: "aych", i: "eye", j: "jay", k: "kay", l: "el",
  m: "em", n: "en", o: "oh", p: "pee", q: "cue", r: "ar",
  s: "ess", t: "tee", u: "you", v: "vee", w: "doubleyou",
  x: "ex", y: "why", z: "zee"
};

// Store visualization state globally - IMPORTANT: This must be defined before any functions that use it
const visualizationState = {
  spiral: {
    points: null,
    frame: 0,
    colors: null,
    animationId: null
  },
  ripple: {
    layers: null,
    frame: 0,
    colors: null,
    animationId: null,
    centerX: 0,
    centerY: 0,
    ringSpacing: 60,
    currentViz: null
  },
  fractal: {
    branches: null,
    frame: 0,
    colors: null,
    animationId: null,
    centerX: 0,
    centerY: 0,
    season: "spring" // spring, summer, fall, winter
  },
  constellation: {
    stars: null,
    connections: null,
    frame: 0,
    colors: null,
    animationId: null,
    centerX: 0,
    centerY: 0,
    twinkleSpeed: 0.05
  },
  waveform: {
    frequencies: null,
    waveData: null,
    frame: 0,
    colors: null,
    animationId: null,
    audioContext: null,
    audioNodes: null,
    isPlaying: false
  }
};

function spellOutArray(chars) {
  return chars.flatMap(c => {
    const mapped = phoneticMap[c.toLowerCase?.()] || c;
    return typeof mapped === 'string' ? mapped.split('') : c.split('');
  });
}

function clearVisuals() {
  d3.select("#tree").style("display", "none").selectAll("*").remove();
  document.getElementById("spiral").style.display = "none";
  document.getElementById("ripple").style.display = "none";
  document.getElementById("fractal").style.display = "none";
  document.getElementById("constellation").style.display = "none";
  document.getElementById("waveform").style.display = "none";
  document.getElementById("typewriterText").textContent = "";
  
  // Hide all visualization containers
  document.querySelectorAll(".visualization-container").forEach(container => {
    container.style.display = "none";
  });
}

function animateTypewriter(text, duration) {
  const typewriterElement = document.getElementById("typewriterText");
  typewriterElement.textContent = "";
  
  if (!text) return;
  
  // Dynamic text scaling based on text length
  const container = document.getElementById("typewriterContainer");
  const containerWidth = container.clientWidth - 150; // Account for controls
  const defaultFontSize = 1.5; // em
  
  // Calculate a font size that will fit the text
  const testSpan = document.createElement("span");
  testSpan.style.fontFamily = "monospace";
  testSpan.style.fontSize = defaultFontSize + "em";
  testSpan.style.visibility = "hidden";
  testSpan.style.whiteSpace = "nowrap";
  testSpan.textContent = text;
  document.body.appendChild(testSpan);
  
  const textWidth = testSpan.offsetWidth;
  document.body.removeChild(testSpan);
  
  // Calculate scaling factor
  let scaleFactor = 1;
  if (textWidth > containerWidth) {
    scaleFactor = Math.max(0.5, containerWidth / textWidth);
  }
  
  // Apply the calculated font size
  typewriterElement.style.fontSize = (defaultFontSize * scaleFactor) + "em";
  
  const totalChars = text.length;
  const charTime = duration / totalChars;
  let currentChar = 0;
  
  function typeNextChar() {
    if (currentChar < totalChars) {
      typewriterElement.textContent += text[currentChar];
      currentChar++;
      setTimeout(typeNextChar, charTime);
    }
  }
  
  typeNextChar();
}

function renderRipple1() {
  const canvas = document.getElementById("ripple");
  const ctx = canvas.getContext("2d");
  canvas.style.display = "block";
  canvas.width = canvas.clientWidth;
  canvas.height = canvas.clientHeight;

  const word = document.getElementById("wordInput").value.trim();
  if (!word) return;

  const layers = [word.split('')];
  for (let i = 1; i <= 3; i++) {
    const nextLayer = spellOutArray(layers[i - 1]);
    if (!nextLayer.length) break;
    layers.push(nextLayer);
  }
  
  // Get the final layer for typewriter animation
  const finalLayer = layers[layers.length - 1];
  const finalText = finalLayer.join('');
  
  // Estimate animation duration (200 frames at 60fps ‚âà 3.33 seconds)
  const animationDuration = 3330;
  
  // Start typewriter animation
  animateTypewriter(finalText, animationDuration);

  const centerX = canvas.width / 2;
  const centerY = canvas.height / 2;
  const ringSpacing = 60;
  const colors = d3.schemeCategory10;

  // Store state for zoom/pan
  visualizationState.ripple.layers = layers;
  visualizationState.ripple.colors = colors;
  visualizationState.ripple.centerX = centerX;
  visualizationState.ripple.centerY = centerY;
  visualizationState.ripple.ringSpacing = ringSpacing;
  visualizationState.ripple.currentViz = "ripple1";
  visualizationState.ripple.frame = 0;
  
  // Cancel any existing animation
  if (visualizationState.ripple.animationId) {
    cancelAnimationFrame(visualizationState.ripple.animationId);
  }

  function drawFrame() {
    // Update frame in state
    visualizationState.ripple.frame++;
    const frame = visualizationState.ripple.frame;
    
    // Draw using the redraw function
    redrawRipple();
    
    if (frame < 200) {
      visualizationState.ripple.animationId = requestAnimationFrame(drawFrame);
    }
  }

  drawFrame();
}

function renderRipple3() {
  const canvas = document.getElementById("ripple");
  canvas.style.display = "block";
  canvas.width = canvas.clientWidth;
  canvas.height = canvas.clientHeight;
  
  const word = document.getElementById("wordInput").value.trim();
  if (!word) return;
  
  const layers = [word.split('')];
  for (let i = 1; i <= 3; i++) {
    const nextLayer = spellOutArray(layers[i - 1]);
    if (!nextLayer.length) break;
    layers.push(nextLayer);
  }
  
  // Get the final layer for typewriter animation
  const finalLayer = layers[layers.length - 1];
  const finalText = finalLayer.join('');
  
  // Animation duration
  const animationDuration = 8000; // 8 seconds for a full animation cycle
  
  // Start typewriter animation
  animateTypewriter(finalText, animationDuration);
  
  const centerX = canvas.width / 2;
  const centerY = canvas.height / 2;
  const ringSpacing = 60;
  const colors = ["#ff6b6b", "#4ecdc4", "#ffe66d", "#ff8c00", "#00cec9", "#ff33cc"];
  
  // Store state for zoom/pan
  visualizationState.ripple.layers = layers;
  visualizationState.ripple.colors = colors;
  visualizationState.ripple.centerX = centerX;
  visualizationState.ripple.centerY = centerY;
  visualizationState.ripple.ringSpacing = ringSpacing;
  visualizationState.ripple.currentViz = "ripple3";
  visualizationState.ripple.frame = 0;
  visualizationState.ripple.animationStartTime = Date.now();
  
  // Cancel any existing animation
  if (visualizationState.ripple.animationId) {
    cancelAnimationFrame(visualizationState.ripple.animationId);
  }
  
  function drawFrame() {
    // Update frame in state
    visualizationState.ripple.frame++;
    
    // Calculate time-based animation
    const elapsedTime = Date.now() - visualizationState.ripple.animationStartTime;
    visualizationState.ripple.elapsedTime = elapsedTime;
    
    // Draw using the redraw function
    redrawRipple3();
    
    // Continue animation
    visualizationState.ripple.animationId = requestAnimationFrame(drawFrame);
  }
  
  drawFrame();
}

// Function to redraw ripple3 without re-calculating
function redrawRipple3() {
  if (!visualizationState.ripple.layers) return;
  
  const canvas = document.getElementById("ripple");
  const ctx = canvas.getContext("2d");
  const transform = getCanvasTransform("ripple");
  const scale = transform.scale;
  const offsetX = transform.offsetX;
  const offsetY = transform.offsetY;
  
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  
  // Apply transform
  const adjustedCenterX = (canvas.width / 2 + offsetX);
  const adjustedCenterY = (canvas.height / 2 + offsetY);
  
  ctx.save();
  ctx.scale(scale, scale);
  
  const layers = visualizationState.ripple.layers;
  const colors = visualizationState.ripple.colors;
  const ringSpacing = visualizationState.ripple.ringSpacing;
  const elapsedTime = visualizationState.ripple.elapsedTime || 0;
  
  // Animation parameters
  const animationPeriod = 8000; // 8 seconds for a full animation cycle
  const animationPhase = (elapsedTime % animationPeriod) / animationPeriod; // 0 to 1
  
  // Draw each layer with animated pulse effect
  layers.forEach((layer, depth) => {
    if (!layer.length) return;
    
    // Calculate pulse effect
    const pulseOffset = depth * 0.1; // Offset pulse timing for each layer
    const pulsePhase = (animationPhase + pulseOffset) % 1;
    
    // Pulse size effect (grows and shrinks)
    const pulseSize = Math.sin(pulsePhase * Math.PI * 2) * 0.3 + 1; // 0.7 to 1.3
    
    // Pulse opacity effect (fades in and out)
    const pulseOpacity = Math.sin(pulsePhase * Math.PI * 2) * 0.4 + 0.6; // 0.2 to 1.0
    
    // Base radius for this layer
    const baseRadius = ringSpacing * (depth + 1) * pulseSize;
    
    // Draw pulsing ring
    ctx.save();
    ctx.globalAlpha = pulseOpacity;
    ctx.strokeStyle = colors[depth % colors.length];
    ctx.lineWidth = 3;
    ctx.beginPath();
    ctx.arc(adjustedCenterX, adjustedCenterY, baseRadius, 0, Math.PI * 2);
    ctx.stroke();
    
    // Draw glow effect
    const glowColor = colors[depth % colors.length];
    const gradient = ctx.createRadialGradient(
      adjustedCenterX, adjustedCenterY, baseRadius - 10,
      adjustedCenterX, adjustedCenterY, baseRadius + 10
    );
    gradient.addColorStop(0, `${glowColor}00`); // 0% opacity
    gradient.addColorStop(0.5, `${glowColor}33`); // 20% opacity
    gradient.addColorStop(1, `${glowColor}00`); // 0% opacity
    
    ctx.strokeStyle = gradient;
    ctx.lineWidth = 20;
    ctx.beginPath();
    ctx.arc(adjustedCenterX, adjustedCenterY, baseRadius, 0, Math.PI * 2);
    ctx.stroke();
    ctx.restore();
    
    // Calculate character positions
    const angleStep = (2 * Math.PI) / layer.length;
    
    // Draw characters with animated movement
    ctx.save();
    ctx.fillStyle = colors[depth % colors.length];
    ctx.font = "18px monospace";
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    
    layer.forEach((char, i) => {
      // Calculate angle with slight rotation over time
      const rotationSpeed = 0.05 * (depth + 1); // Faster rotation for outer layers
      const rotationOffset = elapsedTime * 0.0001 * rotationSpeed;
      const angle = i * angleStep + rotationOffset;
      
      // Add wobble effect
      const wobbleFrequency = 3 + depth; // More wobble for outer layers
      const wobbleAmount = 5 + depth * 2; // Larger wobble for outer layers
      const wobbleOffset = Math.sin(angle * wobbleFrequency + animationPhase * Math.PI * 4) * wobbleAmount;
      
      // Calculate position with pulse and wobble
      const radius = baseRadius + wobbleOffset;
      const x = adjustedCenterX + Math.cos(angle) * radius;
      const y = adjustedCenterY + Math.sin(angle) * radius;
      
      // Draw character with pulsing size
      const charSize = 14 + Math.sin(pulsePhase * Math.PI * 2) * 4; // 10 to 18px
      ctx.font = `${charSize}px monospace`;
      
      // Add slight rotation to each character
      ctx.save();
      ctx.translate(x, y);
      ctx.rotate(angle + Math.PI/2); // Rotate to face outward
      ctx.fillText(char, 0, 0);
      ctx.restore();
    });
    
    ctx.restore();
  });
  
  // Draw central pulse effect
  const centralPulseSize = 20 + Math.sin(animationPhase * Math.PI * 4) * 10;
  const centralPulseOpacity = Math.sin(animationPhase * Math.PI * 4) * 0.4 + 0.6;
  
  ctx.save();
  ctx.globalAlpha = centralPulseOpacity;
  const centralGradient = ctx.createRadialGradient(
    adjustedCenterX, adjustedCenterY, 0,
    adjustedCenterX, adjustedCenterY, centralPulseSize
  );
  centralGradient.addColorStop(0, "#ffffff");
  centralGradient.addColorStop(1, "#ffffff00");
  
  ctx.fillStyle = centralGradient;
  ctx.beginPath();
  ctx.arc(adjustedCenterX, adjustedCenterY, centralPulseSize, 0, Math.PI * 2);
  ctx.fill();
  ctx.restore();
  
  // Draw expanding rings from center
  const numRings = 3;
  for (let i = 0; i < numRings; i++) {
    const ringPhase = (animationPhase + i / numRings) % 1;
    const ringRadius = ringPhase * ringSpacing * layers.length;
    const ringOpacity = 1 - ringPhase; // Fade out as it expands
    
    ctx.save();
    ctx.globalAlpha = ringOpacity * 0.3;
    ctx.strokeStyle = "#ffffff";
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.arc(adjustedCenterX, adjustedCenterY, ringRadius, 0, Math.PI * 2);
    ctx.stroke();
    ctx.restore();
  }
  
  ctx.restore();
}

// Function to toggle waveform audio playback
function toggleWaveformAudio() {
  if (!visualizationState.waveform.oscillators) return;
  
  const isPlaying = !visualizationState.waveform.isPlaying;
  visualizationState.waveform.isPlaying = isPlaying;
  
  // Get current time
  const audioContext = visualizationState.waveform.audioContext;
  const now = audioContext.currentTime;
  
  // Set gain for all oscillators
  visualizationState.waveform.oscillators.forEach((osc, index) => {
    const { gain, layerIndex } = osc;
    
    // Calculate gain based on layer (lower gain for deeper layers)
    const layerGain = Math.pow(0.7, layerIndex);
    
    if (isPlaying) {
      // Fade in
      gain.gain.cancelScheduledValues(now);
      gain.gain.setValueAtTime(gain.gain.value, now);
      gain.gain.linearRampToValueAtTime(layerGain * 0.2, now + 0.1);
    } else {
      // Fade out
      gain.gain.cancelScheduledValues(now);
      gain.gain.setValueAtTime(gain.gain.value, now);
      gain.gain.linearRampToValueAtTime(0, now + 0.1);
    }
  });
}

// Function to redraw waveform without re-calculating
function redrawWaveform() {
  if (!visualizationState.waveform.analyzer) return;
  
  const canvas = document.getElementById("waveform");
  const ctx = canvas.getContext("2d");
  const transform = getCanvasTransform("waveform");
  const scale = transform.scale;
  const offsetX = transform.offsetX;
  const offsetY = transform.offsetY;
  
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  
  // Draw background gradient
  const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
  gradient.addColorStop(0, "#1a1a2e");
  gradient.addColorStop(1, "#16213e");
  ctx.fillStyle = gradient;
  ctx.fillRect(0, 0, canvas.width, canvas.height);
  
  // Apply transform correctly
  ctx.save();
  ctx.translate(offsetX * scale, offsetY * scale);
  ctx.scale(scale, scale);
  
  const analyzer = visualizationState.waveform.analyzer;
  const dataArray = visualizationState.waveform.dataArray;
  const bufferLength = visualizationState.waveform.bufferLength;
  const colors = visualizationState.waveform.colors;
  const oscillators = visualizationState.waveform.oscillators || [];
  const elapsedTime = visualizationState.waveform.elapsedTime || 0;
  const isPlaying = visualizationState.waveform.isPlaying;
  
  // Get frequency data
  analyzer.getByteFrequencyData(dataArray);
  
  // Draw frequency bars
  const barWidth = (canvas.width / bufferLength) * 2;
  let x = 0;
  
  // Draw frequency spectrum
  for (let i = 0; i < bufferLength; i++) {
    const barHeight = (dataArray[i] / 255) * (canvas.height / 2);
    
    // Use gradient for frequency bars
    const barGradient = ctx.createLinearGradient(0, canvas.height / 2 - barHeight, 0, canvas.height / 2);
    barGradient.addColorStop(0, "#e94560");
    barGradient.addColorStop(1, "#e9456033");
    
    ctx.fillStyle = barGradient;
    ctx.fillRect(x, canvas.height / 2 - barHeight, barWidth, barHeight);
    ctx.fillRect(x, canvas.height / 2, barWidth, barHeight);
    
    x += barWidth;
  }
  
  // Draw waveform for each layer
  const centerY = canvas.height / 2;
  const waveHeight = canvas.height / 8;
  
  // Get time domain data
  analyzer.getByteTimeDomainData(dataArray);
  
  // Draw time domain waveform
  ctx.lineWidth = 2;
  ctx.strokeStyle = "#ffffff";
  ctx.beginPath();
  
  const sliceWidth = (canvas.width * 1.0) / bufferLength;
  x = 0;
  
  for (let i = 0; i < bufferLength; i++) {
    const v = dataArray[i] / 128.0;
    const y = v * waveHeight + centerY;
    
    if (i === 0) {
      ctx.moveTo(x, y);
    } else {
      ctx.lineTo(x, y);
    }
    
    x += sliceWidth;
  }
  
  ctx.stroke();
  
  // Draw character markers at their frequencies
  oscillators.forEach((osc, index) => {
    const { frequency, char, layerIndex, charIndex } = osc;
    
    // Calculate x position based on frequency
    // Map frequency to x position (logarithmic scale)
    const minFreq = 220; // A3
    const maxFreq = 880; // A5
    const logMinFreq = Math.log(minFreq);
    const logMaxFreq = Math.log(maxFreq);
    const xPos = ((Math.log(frequency) - logMinFreq) / (logMaxFreq - logMinFreq)) * canvas.width;
    
    // Calculate y position based on layer
    const yPos = centerY + (layerIndex - 1) * waveHeight * 1.5;
    
    // Draw character marker
    const markerSize = 20 - layerIndex * 4;
    const color = colors[layerIndex % colors.length];
    
    // Calculate animation
    const pulsePhase = (elapsedTime * 0.001 + index * 0.1) % 1;
    const pulseFactor = 0.8 + 0.2 * Math.sin(pulsePhase * Math.PI * 2);
    
    // Draw glow
    const glowGradient = ctx.createRadialGradient(
      xPos, yPos, 0,
      xPos, yPos, markerSize * 2
    );
    glowGradient.addColorStop(0, color + "77"); // 50% opacity
    glowGradient.addColorStop(1, "rgba(0,0,0,0)");
    
    ctx.fillStyle = glowGradient;
    ctx.beginPath();
    ctx.arc(xPos, yPos, markerSize * 2 * pulseFactor, 0, Math.PI * 2);
    ctx.fill();
    
    // Draw character
    ctx.fillStyle = isPlaying ? "#ffffff" : color;
    ctx.font = `${markerSize}px monospace`;
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.fillText(char, xPos, yPos);
    
    // Draw frequency label
    ctx.fillStyle = "#ffffff77"; // 50% opacity white
    ctx.font = "10px monospace";
    ctx.fillText(`${Math.round(frequency)}Hz`, xPos, yPos + markerSize + 10);
  });
  
  // Draw play/pause indicator
  const buttonSize = 50;
  const buttonX = canvas.width - buttonSize - 20;
  const buttonY = 20;
  
  ctx.fillStyle = "#16213e";
  ctx.strokeStyle = "#e94560";
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.arc(buttonX + buttonSize/2, buttonY + buttonSize/2, buttonSize/2, 0, Math.PI * 2);
  ctx.fill();
  ctx.stroke();
  
  if (isPlaying) {
    // Draw pause icon
    ctx.fillStyle = "#ffffff";
    ctx.fillRect(buttonX + buttonSize/3, buttonY + buttonSize/4, buttonSize/6, buttonSize/2);
    ctx.fillRect(buttonX + buttonSize/2, buttonY + buttonSize/4, buttonSize/6, buttonSize/2);
  } else {
    // Draw play icon
    ctx.fillStyle = "#ffffff";
    ctx.beginPath();
    ctx.moveTo(buttonX + buttonSize/3, buttonY + buttonSize/4);
    ctx.lineTo(buttonX + buttonSize/3, buttonY + buttonSize*3/4);
    ctx.lineTo(buttonX + buttonSize*2/3, buttonY + buttonSize/2);
    ctx.closePath();
    ctx.fill();
  }
  
  // Draw instructions
  ctx.fillStyle = "#ffffff77"; // 50% opacity white
  ctx.font = "14px monospace";
  ctx.textAlign = "center";
  ctx.fillText("Click anywhere to toggle sound", canvas.width / 2, canvas.height - 20);
  
  ctx.restore();
}

function renderRipple2() {
  const canvas = document.getElementById("ripple");
  canvas.style.display = "block";
  canvas.width = canvas.clientWidth;
  canvas.height = canvas.clientHeight;
  
  const word = document.getElementById("wordInput").value.trim();
  if (!word) return;
  
  const layers = [word.split('')];
  for (let i = 1; i <= 3; i++) {
    const nextLayer = spellOutArray(layers[i - 1]);
    if (!nextLayer.length) break;
    layers.push(nextLayer);
  }
  
  // Get the final layer for typewriter animation
  const finalLayer = layers[layers.length - 1];
  const finalText = finalLayer.join('');
  
  // Animation duration
  const animationDuration = 5000; // 5 seconds for a full pulse cycle
  
  // Start typewriter animation
  animateTypewriter(finalText, animationDuration);
  
  const centerX = canvas.width / 2;
  const centerY = canvas.height / 2;
  const ringSpacing = 60;
  const colors = ["#ff6b6b", "#4ecdc4", "#ffe66d", "#ff8c00", "#00cec9", "#ff33cc"];
  
  // Store state for zoom/pan
  visualizationState.ripple.layers = layers;
  visualizationState.ripple.colors = colors;
  visualizationState.ripple.centerX = centerX;
  visualizationState.ripple.centerY = centerY;
  visualizationState.ripple.ringSpacing = ringSpacing;
  visualizationState.ripple.currentViz = "ripple2";
  visualizationState.ripple.frame = 0;
  visualizationState.ripple.animationStartTime = Date.now();
  
  // Cancel any existing animation
  if (visualizationState.ripple.animationId) {
    cancelAnimationFrame(visualizationState.ripple.animationId);
  }
  
  function drawFrame() {
    // Update frame in state
    visualizationState.ripple.frame++;
    
    // Calculate time-based animation
    const elapsedTime = Date.now() - visualizationState.ripple.animationStartTime;
    visualizationState.ripple.elapsedTime = elapsedTime;
    
    // Draw using the redraw function
    redrawRipple2();
    
    // Continue animation
    visualizationState.ripple.animationId = requestAnimationFrame(drawFrame);
  }
  
  drawFrame();
}

// Function to redraw ripple2 without re-calculating
function redrawRipple2() {
  if (!visualizationState.ripple.layers) return;
  
  const canvas = document.getElementById("ripple");
  const ctx = canvas.getContext("2d");
  const transform = getCanvasTransform("ripple");
  const scale = transform.scale;
  const offsetX = transform.offsetX;
  const offsetY = transform.offsetY;
  
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  
  // Apply transform
  const adjustedCenterX = (canvas.width / 2 + offsetX);
  const adjustedCenterY = (canvas.height / 2 + offsetY);
  
  ctx.save();
  ctx.scale(scale, scale);
  
  const layers = visualizationState.ripple.layers;
  const colors = visualizationState.ripple.colors;
  const ringSpacing = visualizationState.ripple.ringSpacing;
  const elapsedTime = visualizationState.ripple.elapsedTime || 0;
  
  // Animation parameters
  const pulsePeriod = 5000; // 5 seconds for a full pulse cycle
  const pulsePhase = (elapsedTime % pulsePeriod) / pulsePeriod; // 0 to 1
  const breathingFactor = Math.sin(pulsePhase * Math.PI * 2) * 0.15 + 1; // 0.85 to 1.15
  
  // Draw each layer as a wavy circle
  layers.forEach((layer, depth) => {
    if (!layer.length) return;
    
    const baseRadius = ringSpacing * (depth + 1) * breathingFactor;
    const waveAmplitude = 5 + depth * 3; // Increase amplitude with depth
    const waveFrequency = 6; // Number of waves around the circle
    const wavePhaseOffset = depth * 0.5; // Offset each layer's wave phase
    
    // Draw glow effect
    ctx.save();
    const glowColor = colors[depth % colors.length];
    const gradient = ctx.createRadialGradient(
      adjustedCenterX, adjustedCenterY, baseRadius - waveAmplitude - 5,
      adjustedCenterX, adjustedCenterY, baseRadius + waveAmplitude + 5
    );
    gradient.addColorStop(0, 'rgba(0,0,0,0)');
    gradient.addColorStop(0.5, `${glowColor}33`); // 20% opacity
    gradient.addColorStop(1, 'rgba(0,0,0,0)');
    
    ctx.strokeStyle = gradient;
    ctx.lineWidth = 10;
    ctx.beginPath();
    
    // Draw wavy circle path
    for (let i = 0; i <= 360; i++) {
      // Adjust angle to start at top (0 degrees) instead of right (90 degrees)
      const angle = ((i - 90) * Math.PI) / 180;
      const waveOffset = Math.sin(angle * waveFrequency + pulsePhase * Math.PI * 2 + wavePhaseOffset) * waveAmplitude;
      const radius = baseRadius + waveOffset;
      const x = adjustedCenterX + Math.cos(angle) * radius;
      const y = adjustedCenterY + Math.sin(angle) * radius;
      
      if (i === 0) {
        ctx.moveTo(x, y);
      } else {
        ctx.lineTo(x, y);
      }
    }
    
    ctx.closePath();
    ctx.stroke();
    ctx.restore();
    
    // Draw characters along the wavy path
    ctx.save();
    ctx.fillStyle = colors[depth % colors.length];
    ctx.font = "18px monospace";
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    
    const angleStep = (2 * Math.PI) / layer.length;
    
    layer.forEach((char, i) => {
      // Adjust angle to start at top (0 degrees) instead of right (90 degrees)
      const angle = i * angleStep - Math.PI/2;
      const waveOffset = Math.sin(angle * waveFrequency + pulsePhase * Math.PI * 2 + wavePhaseOffset) * waveAmplitude;
      const radius = baseRadius + waveOffset;
      const x = adjustedCenterX + Math.cos(angle) * radius;
      const y = adjustedCenterY + Math.sin(angle) * radius;
      
      // Rotate text to follow the circle
      ctx.save();
      ctx.translate(x, y);
      ctx.rotate(angle + Math.PI/2);
      ctx.fillText(char, 0, 0);
      ctx.restore();
    });
    
    ctx.restore();
  });
  
  ctx.restore();
}

// Function to redraw spiral without re-calculating
function redrawSpiral() {
  if (!visualizationState.spiral.points) return;
  
  const canvas = document.getElementById("spiral");
  const ctx = canvas.getContext("2d");
  const transform = getCanvasTransform("spiral");
  const scale = transform.scale;
  const offsetX = transform.offsetX;
  const offsetY = transform.offsetY;
  
  ctx.setTransform(1, 0, 0, 1, 0, 0);
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  
  const cx = canvas.width / 2 + offsetX;
  const cy = canvas.height / 2 + offsetY;
  
  ctx.save();
  ctx.scale(scale, scale);
  
  const points = visualizationState.spiral.points;
  const colors = visualizationState.spiral.colors;
  const frame = visualizationState.spiral.frame;
  
  for (let i = 0; i <= frame && i < points.length; i++) {
    const p = points[i];
    if (!p.char || typeof p.char !== 'string') continue;
    ctx.fillStyle = colors[p.level % colors.length];
    ctx.font = "20px monospace";
    ctx.fillText(p.char, cx + p.x, cy + p.y);
  }
  
  ctx.restore();
}

// Function to redraw ripple without re-calculating
function redrawRipple() {
  if (!visualizationState.ripple.layers) return;
  
  const canvas = document.getElementById("ripple");
  const ctx = canvas.getContext("2d");
  const transform = getCanvasTransform("ripple");
  const scale = transform.scale;
  const offsetX = transform.offsetX;
  const offsetY = transform.offsetY;
  
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  
  // For ripple1 visualization
  const adjustedCenterX = (canvas.width / 2 + offsetX);
  const adjustedCenterY = (canvas.height / 2 + offsetY);
  
  ctx.save();
  ctx.scale(scale, scale);
  
  const layers = visualizationState.ripple.layers;
  const colors = visualizationState.ripple.colors;
  const frame = visualizationState.ripple.frame;
  const ringSpacing = visualizationState.ripple.ringSpacing;
  
  function easeOutBounce(x) {
    const n1 = 7.5625, d1 = 2.75;
    if (x < 1 / d1) return n1 * x * x;
    else if (x < 2 / d1) return n1 * (x -= 1.5 / d1) * x + 0.75;
    else if (x < 2.5 / d1) return n1 * (x -= 2.25 / d1) * x + 0.9375;
    else return n1 * (x -= 2.625 / d1) * x + 0.984375;
  }
  
  const baseRevealInterval = 15;
  const baseFadeDuration = 20;
  
  layers.forEach((layer, depth) => {
    if (!layer.length) return;
    const revealFrame = depth * baseRevealInterval;
    const fadeDuration = baseFadeDuration + depth * 5;
    if (frame < revealFrame) return;
    
    const progress = Math.min(1, (frame - revealFrame) / fadeDuration);
    const easedProgress = easeOutBounce(progress * 0.95);
    const baseRadius = ringSpacing * (depth + 1);
    const prevRadius = ringSpacing * depth;
    const animatedRadius = prevRadius + (baseRadius - prevRadius) * easedProgress;
    
    const maxDensity = 0.12; // max radians per char (~1 char per 8 deg)
    const angleStep = Math.max((2 * Math.PI) / layer.length, maxDensity);
    // Start at top (0 degrees)
    const startAngle = -Math.PI / 2; // This is already at top (0 degrees in standard position)
    
    ctx.save();
    const baseFontSize = 24;
    const fontSize = Math.min(baseFontSize, (2 * Math.PI * animatedRadius) / (layer.length * 1.2));
    ctx.font = `${fontSize}px monospace`;
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    
    // Faded debug ring at final radius
    ctx.beginPath();
    ctx.arc(adjustedCenterX, adjustedCenterY, baseRadius, 0, 2 * Math.PI);
    ctx.strokeStyle = colors[depth % colors.length];
    ctx.globalAlpha = 0.05;
    ctx.stroke();
    
    ctx.fillStyle = colors[depth % colors.length];
    ctx.globalAlpha = progress;
    
    layer.forEach((char, i) => {
      const angle = startAngle + i * angleStep;
      const x = adjustedCenterX + Math.cos(angle) * animatedRadius;
      const y = adjustedCenterY + Math.sin(angle) * animatedRadius;
      ctx.fillText(char, x, y);
    });
    ctx.restore();
  });
  
  ctx.restore();
}

// Apply transform to canvas drawing functions
function getCanvasTransform(canvasId) {
  const canvas = document.getElementById(canvasId);
  return {
    scale: parseFloat(canvas.dataset.scale || 1),
    offsetX: parseFloat(canvas.dataset.offsetX || 0),
    offsetY: parseFloat(canvas.dataset.offsetY || 0)
  };
}

// Canvas visualizations zoom/pan functionality
(function setupCanvasZoomPan() {
  const canvasIds = ["spiral", "ripple", "fractal", "constellation", "waveform"];
  
  canvasIds.forEach(canvasId => {
    const canvas = document.getElementById(canvasId);
    const ctx = canvas.getContext("2d");
    let scale = 1;
    let offsetX = 0;
    let offsetY = 0;
    let isDragging = false;
    let lastX, lastY;
    const minScale = 0.2;
    const maxScale = 5;
    
    // Add mouse wheel zoom functionality with centered zooming
    canvas.addEventListener("wheel", (event) => {
      event.preventDefault();
      
      // Get mouse position relative to canvas
      const rect = canvas.getBoundingClientRect();
      const mouseX = event.clientX - rect.left;
      const mouseY = event.clientY - rect.top;
      
      // Convert mouse position to canvas coordinates
      const canvasX = mouseX / scale - offsetX;
      const canvasY = mouseY / scale - offsetY;
      
      // Calculate new scale
      const delta = event.deltaY < 0 ? 0.1 : -0.1;
      const newScale = Math.max(minScale, Math.min(maxScale, scale + delta));
      
      // Adjust offset to keep the point under the mouse fixed
      offsetX = offsetX - (canvasX * (newScale - scale)) / newScale;
      offsetY = offsetY - (canvasY * (newScale - scale)) / newScale;
      
      // Update scale
      scale = newScale;
      
      // Store transform values
      canvas.dataset.scale = scale;
      canvas.dataset.offsetX = offsetX;
      canvas.dataset.offsetY = offsetY;
      
      // Redraw without re-calculating
      if (canvasId === "spiral") {
        redrawSpiral();
      } else if (canvasId === "ripple") {
        if (visualizationState.ripple.currentViz === "ripple1") {
          redrawRipple();
        } else if (visualizationState.ripple.currentViz === "ripple2") {
          redrawRipple2();
        } else if (visualizationState.ripple.currentViz === "ripple3") {
          redrawRipple3();
        }
      } else if (canvasId === "fractal") {
        redrawFractal();
      } else if (canvasId === "constellation") {
        redrawConstellation();
      } else if (canvasId === "waveform") {
        redrawWaveform();
      }
    });
    
    // Mouse events for panning
    canvas.addEventListener("mousedown", (e) => {
      isDragging = true;
      lastX = e.clientX;
      lastY = e.clientY;
    });
    
    canvas.addEventListener("mousemove", (e) => {
      if (isDragging) {
        offsetX += (e.clientX - lastX) / scale;
        offsetY += (e.clientY - lastY) / scale;
        lastX = e.clientX;
        lastY = e.clientY;
        
        canvas.dataset.scale = scale;
        canvas.dataset.offsetX = offsetX;
        canvas.dataset.offsetY = offsetY;
        
        // Redraw without re-calculating
        if (canvasId === "spiral") {
          redrawSpiral();
        } else if (canvasId === "ripple") {
          if (visualizationState.ripple.currentViz === "ripple1") {
            redrawRipple();
          } else if (visualizationState.ripple.currentViz === "ripple2") {
            redrawRipple2();
          } else if (visualizationState.ripple.currentViz === "ripple3") {
            redrawRipple3();
          }
        } else if (canvasId === "fractal") {
          redrawFractal();
        } else if (canvasId === "constellation") {
          redrawConstellation();
        } else if (canvasId === "waveform") {
          redrawWaveform();
        }
      }
    });
    
    canvas.addEventListener("mouseup", () => {
      isDragging = false;
    });
    
    canvas.addEventListener("mouseleave", () => {
      isDragging = false;
    });
  });
})();

// Function to render the currently selected visualization
function renderSelectedVisualization() {
  const choice = document.getElementById("visualizationSelect").value;
  
  const word = document.getElementById("wordInput").value.trim();
  
  if (!word) {
    return;
  }
  
  // If no visualization is selected, default to tree
  if (!choice || choice === "") {
    document.getElementById("visualizationSelect").value = "tree";
    document.getElementById("treeContainer").style.display = "block";
    renderTree();
    return;
  }
  
  clearVisuals();
  
  // Hide all visualization containers first
  document.querySelectorAll(".visualization-container").forEach(container => {
    container.style.display = "none";
  });
  
  // Show the appropriate container and render the selected visualization
  if (choice === "tree") {
    document.getElementById("treeContainer").style.display = "block";
    renderTree();
  }
  else if (choice === "spiral") {
    document.getElementById("spiralContainer").style.display = "block";
    renderSpiral();
  }
  else if (choice === "ripple1") {
    document.getElementById("rippleContainer").style.display = "block";
    renderRipple1();
  }
  else if (choice === "ripple2") {
    document.getElementById("rippleContainer").style.display = "block";
    renderRipple2();
  }
  else if (choice === "ripple3") {
    document.getElementById("rippleContainer").style.display = "block";
    renderRipple3();
  }
  else if (choice === "waveform") {
    document.getElementById("waveformContainer").style.display = "block";
    renderWaveform();
  }
  else if (choice === "fractal") {
    document.getElementById("fractalContainer").style.display = "block";
    renderFractal();
  }
  else if (choice === "constellation") {
    document.getElementById("constellationContainer").style.display = "block";
    renderConstellation();
  }
  else {
    // Default to tree if unknown visualization type
    document.getElementById("treeContainer").style.display = "block";
    renderTree();
  }
}

// Add event listeners for visualization selection and word input
document.addEventListener("DOMContentLoaded", function() {
  // Add event listener for visualization selection change
  document.getElementById("visualizationSelect").addEventListener("change", renderSelectedVisualization);

  // Add event listener for word input
  document.getElementById("wordInput").addEventListener("input", function(e) {
    const word = e.target.value.trim();
    if (word.length > 0) {
      renderSelectedVisualization();
    }
  });

  // Initialize the page with a default visualization if there's a word in the input
  const word = document.getElementById("wordInput").value.trim();
  if (word.length > 0) {
    // Set default visualization to tree if none selected
    if (!document.getElementById("visualizationSelect").value || 
        document.getElementById("visualizationSelect").value === "") {
      document.getElementById("visualizationSelect").value = "tree";
    }
    renderSelectedVisualization();
  }
});

// Tree visualization
function renderTree() {
  // Get the word from the input
  const word = document.getElementById("wordInput").value.trim();
  
  if (!word) {
    return;
  }
  
  // Clear the SVG
  const svg = d3.select("#tree");
  svg.style("display", "block").selectAll("*").remove();
  
  // Make sure the SVG container is visible
  document.getElementById("treeContainer").style.display = "block";
  
  // Get SVG dimensions
  const width = svg.node().clientWidth;
  const height = svg.node().clientHeight;
  
  // Build tree data
  function buildTree(word, depth = 3) {
    function recurse(word, level) {
      if (level >= depth) return { name: word };
      return {
        name: word,
        children: word.split('').map(char =>
          recurse(phoneticMap[char.toLowerCase()] || char, level + 1)
        )
      };
    }
    return recurse(word, 0);
  }
  
  // Get the final layer for typewriter animation
  let finalText = "";
  function collectLeaves(word, level = 0, maxDepth = 3) {
    if (level >= maxDepth) {
      finalText += word;
      return;
    }
    word.split('').forEach(char => {
      collectLeaves(phoneticMap[char.toLowerCase()] || char, level + 1, maxDepth);
    });
  }
  collectLeaves(word);
  
  // Estimate animation duration based on tree complexity
  const estimatedNodes = word.length * 4; // Rough estimate of total nodes
  const animationDuration = estimatedNodes * 100;
  
  // Start typewriter animation
  animateTypewriter(finalText, animationDuration);
  
  // Create the tree layout
  const root = d3.hierarchy(buildTree(word));
  const treeLayout = d3.tree().size([height, width - 160]);
  treeLayout(root);
  
  // Add the links
  const g = svg.append("g").attr("transform", "translate(80,0)");
  const linkPath = d3.linkHorizontal()
    .x(d => d.y)
    .y(d => d.x);
  
  g.selectAll(".link")
    .data(root.links())
    .join("path")
    .attr("class", "link")
    .attr("d", linkPath)
    .style("stroke-dasharray", function() {
      const length = this.getTotalLength();
      return length + "," + length;
    })
    .style("stroke-dashoffset", function() {
      return this.getTotalLength();
    })
    .transition()
    .duration(1000)
    .delay((d, i) => i * 100)
    .style("stroke-dashoffset", 0);
  
  // Add the nodes
  const node = g.selectAll(".node")
    .data(root.descendants())
    .join("g")
    .attr("class", "node")
    .style("opacity", 0)
    .attr("transform", d => `translate(${d.y},${d.x})`);
  
  node.append("circle").attr("r", 4);
  node.append("text")
    .attr("dy", 3)
    .attr("x", d => d.children ? -8 : 8)
    .style("text-anchor", d => d.children ? "end" : "start")
    .text(d => d.data.name);
  
  node.transition()
    .delay((d, i) => i * 100)
    .duration(500)
    .style("opacity", 1);
  
  // Setup zoom and pan for the tree
  setupTreeZoomPan();
}

// Setup tree zoom/pan functionality
function setupTreeZoomPan() {
  const svg = d3.select("#tree");
  const g = svg.select("g");
  
  // Create a zoom behavior
  const zoom = d3.zoom()
    .scaleExtent([0.2, 5])
    .on("zoom", (event) => {
      g.attr("transform", event.transform);
    });
  
  // Apply the zoom behavior to the SVG
  svg.call(zoom);
  
  // Initialize with a slight offset for better visibility
  svg.call(zoom.transform, d3.zoomIdentity.translate(80, 0));
}

// Spiral visualization
function renderSpiral() {
  const canvas = document.getElementById("spiral");
  canvas.style.display = "block";
  const ctx = canvas.getContext("2d");
  canvas.width = canvas.clientWidth;
  canvas.height = canvas.clientHeight;
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  const word = document.getElementById("wordInput").value.trim();
  if (!word) return;
  
  const layers = [word.split('')];
  for (let i = 1; i <= 3; i++) {
    layers.push(spellOutArray(layers[i - 1]));
  }
  
  // Get the final layer for typewriter animation
  const finalLayer = layers[layers.length - 1];
  const finalText = finalLayer.join('');
  
  // Calculate total number of points for animation duration
  const totalPoints = layers.reduce((sum, layer) => sum + layer.length, 0);
  // Estimate animation duration (16ms per point ‚âà 60fps)
  const animationDuration = totalPoints * 16;
  
  // Start typewriter animation
  animateTypewriter(finalText, animationDuration);

  const spiralPoints = layers.flatMap((layer, depth) =>
    layer.map((char, i) => {
      const index = i + layers.slice(0, depth).reduce((a, l) => a + l.length, 0);
      const angle = 0.22 * index;
      let radius;
      if (depth === 0) radius = 25 + index * 3.2;
      else if (depth === 1) radius = 22 + index * 2.8;
      else radius = 15 + index * 2.2;
      return {
        x: Math.cos(angle) * radius,
        y: Math.sin(angle) * radius,
        char,
        level: depth
      };
    })
  );

  // Store state for zoom/pan
  visualizationState.spiral.points = spiralPoints;
  visualizationState.spiral.colors = ["#ff6b6b", "#4ecdc4", "#ffe66d", "#ff8c00", "#00cec9", "#ff33cc"];
  visualizationState.spiral.frame = 0;
  
  // Cancel any existing animation
  if (visualizationState.spiral.animationId) {
    cancelAnimationFrame(visualizationState.spiral.animationId);
  }

  function animate() {
    // Update frame in state
    visualizationState.spiral.frame++;
    
    // Draw using the redraw function
    redrawSpiral();
    
    if (visualizationState.spiral.frame < spiralPoints.length) {
      visualizationState.spiral.animationId = requestAnimationFrame(animate);
    }
  }

  animate();
}

// Waveform visualization
function renderWaveform() {
  const canvas = document.getElementById("waveform");
  canvas.style.display = "block";
  const ctx = canvas.getContext("2d");
  canvas.width = canvas.clientWidth;
  canvas.height = canvas.clientHeight;
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  const word = document.getElementById("wordInput").value.trim();
  if (!word) return;
  
  const layers = [word.split('')];
  for (let i = 1; i <= 2; i++) { // Limit to 2 levels for better performance
    const nextLayer = spellOutArray(layers[i - 1]);
    if (!nextLayer.length) break;
    layers.push(nextLayer);
  }
  
  // Get the final layer for typewriter animation
  const finalLayer = layers[layers.length - 1];
  const finalText = finalLayer.join('');
  
  // Animation duration
  const animationDuration = 5000; // 5 seconds for full animation cycle
  
  // Start typewriter animation
  animateTypewriter(finalText, animationDuration);
  
  // Create audio context if needed
  if (!visualizationState.waveform.audioContext) {
    try {
      const AudioContext = window.AudioContext || window.webkitAudioContext;
      visualizationState.waveform.audioContext = new AudioContext();
    } catch (e) {
      console.error("Web Audio API is not supported in this browser");
      // Draw fallback message
      ctx.fillStyle = "#e94560";
      ctx.font = "24px monospace";
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.fillText("Web Audio API not supported in this browser", canvas.width / 2, canvas.height / 2);
      return;
    }
  }
  
  const audioContext = visualizationState.waveform.audioContext;
  
  // Clean up previous audio nodes
  if (visualizationState.waveform.audioNodes) {
    visualizationState.waveform.audioNodes.forEach(node => {
      try {
        node.disconnect();
      } catch (e) {
        // Node might already be disconnected
      }
    });
  }
  
  // Create new audio nodes
  const audioNodes = [];
  const masterGain = audioContext.createGain();
  masterGain.gain.value = 0.1; // Low volume to prevent loud sounds
  masterGain.connect(audioContext.destination);
  audioNodes.push(masterGain);
  
  // Create analyzer for visualization
  const analyzer = audioContext.createAnalyser();
  analyzer.fftSize = 2048;
  analyzer.connect(masterGain);
  audioNodes.push(analyzer);
  
  // Convert characters to frequencies
  const baseFrequency = 220; // A3
  const frequencies = [];
  
  // Map each character to a frequency based on its position in the alphabet
  // A = 220Hz, B = 233.08Hz, etc. (following equal temperament)
  function charToFrequency(char) {
    const lowerChar = char.toLowerCase();
    if (lowerChar >= 'a' && lowerChar <= 'z') {
      const position = lowerChar.charCodeAt(0) - 'a'.charCodeAt(0);
      return baseFrequency * Math.pow(2, position / 12); // Equal temperament
    } else {
      // For non-alphabetic characters, use a default frequency
      return baseFrequency;
    }
  }
  
  // Create oscillators for each character in each layer
  const oscillators = [];
  
  layers.forEach((layer, layerIndex) => {
    layer.forEach((char, charIndex) => {
      const frequency = charToFrequency(char);
      
      // Create oscillator
      const oscillator = audioContext.createOscillator();
      oscillator.type = layerIndex === 0 ? 'sine' : (layerIndex === 1 ? 'triangle' : 'sawtooth');
      oscillator.frequency.value = frequency;
      
      // Create gain node for this oscillator
      const gain = audioContext.createGain();
      gain.gain.value = 0; // Start silent
      
      // Connect oscillator to its gain node, then to analyzer
      oscillator.connect(gain);
      gain.connect(analyzer);
      
      // Start oscillator
      oscillator.start();
      
      // Store oscillator and gain node
      oscillators.push({
        oscillator,
        gain,
        frequency,
        char,
        layerIndex,
        charIndex
      });
      
      // Add to audio nodes for cleanup
      audioNodes.push(oscillator, gain);
    });
  });
  
  // Store frequencies for visualization
  visualizationState.waveform.frequencies = oscillators.map(osc => ({
    frequency: osc.frequency,
    char: osc.char,
    layerIndex: osc.layerIndex,
    charIndex: osc.charIndex
  }));
  
  // Create buffer for analyzer data
  const bufferLength = analyzer.frequencyBinCount;
  const dataArray = new Uint8Array(bufferLength);
  
  // Color palette for waveforms
  const colors = [
    "#ff6b6b", // Red for original word
    "#4ecdc4", // Teal for first phonetic level
    "#ffe66d"  // Yellow for second phonetic level
  ];
  
  // Store state for zoom/pan
  visualizationState.waveform.analyzer = analyzer;
  visualizationState.waveform.dataArray = dataArray;
  visualizationState.waveform.bufferLength = bufferLength;
  visualizationState.waveform.colors = colors;
  visualizationState.waveform.oscillators = oscillators;
  visualizationState.waveform.audioNodes = audioNodes;
  visualizationState.waveform.animationStartTime = Date.now();
  visualizationState.waveform.animationDuration = animationDuration;
  visualizationState.waveform.isPlaying = false;
  
  // Cancel any existing animation
  if (visualizationState.waveform.animationId) {
    cancelAnimationFrame(visualizationState.waveform.animationId);
  }
  
  // Add click handler to play/pause audio
  canvas.onclick = function() {
    toggleWaveformAudio();
  };
  
  function drawFrame() {
    // Calculate time-based animation
    const elapsedTime = Date.now() - visualizationState.waveform.animationStartTime;
    visualizationState.waveform.elapsedTime = elapsedTime;
    
    // Draw using the redraw function
    redrawWaveform();
    
    // Continue animation
    visualizationState.waveform.animationId = requestAnimationFrame(drawFrame);
  }
  
  drawFrame();
}
